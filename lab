1. Планування

Мета продукту

Користувач повинен мати можливість отримати рекомендації щодо оптимального часу сну на основі 90-хвилинних циклів, щоб прокидатися в кінці циклу й почуватися більш бадьорим.

2. Аналіз вимог (User stories)

(Must have)
Як користувач, я хочу ввести бажаний час пробудження, щоб застосунок порахував, о котрій годині мені краще лягати спати.

(Must have)
Як користувач, я хочу бачити декілька варіантів часу відходу до сну (наприклад, 3–6 варіантів), щоб обрати той, який мені підходить за розкладом.

Як користувач, я хочу, щоб застосунок враховував приблизний час засинання (наприклад, 10–20 хвилин), щоб рекомендації були ближчими до реальності.

Як користувач, я хочу мати можливість ввести поточний час, щоб отримати рекомендації, о котрій краще прокинутися (список часу пробудження з урахуванням циклів).

Як користувач, я хочу бачити коротке пояснення, чому саме ці часи сну рекомендуються, щоб краще розуміти принцип 90-хвилинних циклів.

Позначка:

Must have: User Story 1, User Story 2

Інші — Nice to have / Should have.

3. Дизайн (прототипи екранів)

Мінімум 2 екрани:

Головний екран

Екран з результатами (список рекомендованих часів
еалізація (імітація) — псевдокод ключової функції

Візьмемо ключову функцію:
Обчислити рекомендований час відходу до сну за бажаним часом пробудження.

Вихідні дані:

wakeTime — бажаний час пробудження (година + хвилини)

fallAsleepMinutes — скільки хвилин користувачу потрібно, щоб заснути (наприклад, 15)

cyclesCountList — список кількості циклів, наприклад: [3, 4, 5, 6]

Псевдокод
function calculateBedtimes(wakeTime, fallAsleepMinutes, cyclesCountList):
    # wakeTime: структура з полями hour, minute (24-годинний формат)
    # fallAsleepMinutes: ціле число (15, 20, ...)
    # cyclesCountList: список можливих кількостей циклів, наприклад [3,4,5,6]

    resultList = []  # список результатів: (час_сну, кількість_циклів)

    for cycles in cyclesCountList:
        totalSleepMinutes = cycles * 90           # 90 хв – один цикл
        totalMinutesToSubtract = totalSleepMinutes + fallAsleepMinutes

        # Перевести час пробудження в хвилини від початку доби
        wakeInMinutes = wakeTime.hour * 60 + wakeTime.minute

        # Час відходу до сну = час пробудження – (сон + засинання)
        bedInMinutes = wakeInMinutes - totalMinutesToSubtract

        # Якщо вийшло менше 0 – додаємо 24 години (перехід на попередню добу)
        if bedInMinutes < 0:
            bedInMinutes = bedInMinutes + 24 * 60

        # Конвертуємо назад у години та хвилини
        bedHour = floor(bedInMinutes / 60)
        bedMinute = bedInMinutes % 60

        # Форматуємо як HH:MM (з нулем попереду, якщо < 10)
        bedTimeString = formatTime(bedHour, bedMinute)

        # Додаємо в список результатів
        resultList.append( (bedTimeString, cycles) )

    return resultList

5. Тестування — приклади тестів

Тестуємо цю саму функцію calculateBedtimes.

Передумова для всіх тестів:

fallAsleepMinutes = 15

cyclesCountList = [3, 4]

Тест 1

Сценарій:
Ввід: wakeTime = 07:00, fallAsleepMinutes = 15, cyclesCountList = [3, 4]
Очікуваний результат:

Для 3 циклів:

Загальний сон = 3 * 90 = 270 хв

Разом з засинанням: 270 + 15 = 285 хв

07:00 → 7 * 60 = 420 хв

420 – 285 = 135 хв → 02:15

Для 4 циклів:

Сон = 4 * 90 = 360 хв

+15 = 375 хв

420 – 375 = 45 хв → 00:45

Перевірка:
Функція повертає:

("02:15", 3)

("00:45", 4)

Тест 2

Сценарій:
Ввід: wakeTime = 06:30, fallAsleepMinutes = 15, cyclesCountList = [3]

Розрахунок:

Сон = 270 хв

+15 = 285

06:30 → 6 * 60 + 30 = 390 хв

390 – 285 = 105 хв → 01:45

Очікувано:
Функція повертає один варіант: ("01:45", 3).

Тест 3 (перехід через північ)

Сценарій:
Ввід: wakeTime = 04:30, fallAsleepMinutes = 15, cyclesCountList = [4]

Розрахунок:

Сон = 4 * 90 = 360 хв

+15 = 375

04:30 → 4 * 60 + 30 = 270 хв

270 – 375 = -105 хв → додаємо 24 * 60 = 1440 хв

-105 + 1440 = 1335 хв

1335 / 60 = 22 год (залишок 15 хв) → 22:15

Очікувано:
Функція повертає: ("22:15", 4).

6. Висновок: вибір моделі SDLC

Для такого проєкту (простий застосунок з можливістю подальшого розширення функцій) найкраще підходить модель Agile (ітеративна розробка).

Спочатку можна реалізувати базовий функціонал (ввід часу, розрахунок циклів, вивід результатів — Must have).

Потім — додавати покращення: налаштування тривалості циклу, статистику сну, історію, персональні рекомендації тощо, реагуючи на фідбек користувачів.
